#!/usr/bin/env node
const fs = require("fs");
const {
  results
} = JSON.parse(
  fs.readFileSync(process.argv.slice(2).flat()[0])
);
const filename = `${process.argv.slice(2).flat()[1]}`;

var earliestRecord = {};
earliestRecord.errors = {};

const applyTags = (album) => {
  earliestRecord.album_artist = earliestRecord.ALBUMARTIST = album.artists[0].name
  earliestRecord.artist = earliestRecord.ARTIST = album.mediums[0].tracks[0].artists[0].name
  earliestRecord.album = earliestRecord.ALBUM = album.title;
  earliestRecord.disc = album.mediums[0].position;
  earliestRecord.tracknumber = earliestRecord.track =
  album.mediums[0].tracks[0].position;
  earliestRecord.TRACKTOTAL = album.track_count;
  earliestRecord.title = earliestRecord.TITLE =
  album.mediums[0].tracks[0].title;
  earliestRecord.MUSICBRAINZ_ALBUMARTISTID = album.artists[0].id;
  earliestRecord.MUSICBRAINZ_TRACKID = album.mediums[0].tracks[0].id;
  earliestRecord.MUSICBRAINZ_ALBUMID = album.id;
};

const eachIfDefined = (arr, cb) => {
  if (Array.isArray(arr) && typeof arr !== "undefined") {
    arr.forEach(cb);
  } else {
    return null;
  }
};

var albums = [];

const getEarliestRelease = (results) => {
  // get only first result - they are returned by acoustID
  // in order of best score, so there's a chance a bad score
  // will give a "better" result which will give the wrong title.
  //
  // get all releases of type: "album"
  earliestRecord.epoch = Date.parse(new Date);
  // set date to RIGHT THIS MILLISECOND. it can only get older from here.

  results.forEach((result)=> {
    earliestRecord.score = result.score;
    if (result.score < 0.95) {
      earliestRecord.ACOUSTID_ID = result.id;
      eachIfDefined(result.recordings, (recording) => {
        //earliestRecord.artist = earliestRecord.ARTIST = recording.artists[0].name;
        eachIfDefined(recording.releasegroups, (releasegroup) => {
          if (releasegroup.type === "Album") {
            // albums.push(releasegroup.releases);
            eachIfDefined(releasegroup.releases, (release) => {
              if (release.date) {
                albums.push(release);
              }
            });
          }
        });
      });
    }
  });

  albums.forEach((album) => {
    // get earliest date.
    // some dates are only a year, so we first
    // check if there's a "day".
    if ("day" in album.date) {
      delete earliestRecord.errors.day;
      delete earliestRecord.errors.month;
      delete earliestRecord.errors.year;
      let date = `${("000" + album.date.year).slice(-4)}-${(
        "0" + album.date.month
      ).slice(-2)}-${("0" + album.date.day).slice(-2)}`;
      let dateObj = Date.parse(date);

      if (dateObj < earliestRecord.epoch) {
        // apply all the tags
        earliestRecord.date = earliestRecord.ORIGINALDATE = `${(
          "000" + album.date.year
        ).slice(-4)}-${("0" + album.date.month).slice(-2)}-${(
          "0" + album.date.day
        ).slice(-2)}`;
        earliestRecord.year = earliestRecord.ORIGINALYEAR = `${(
          "000" + album.date.year
        ).slice(-4)}`;
        earliestRecord.epoch = Date.parse(earliestRecord.ORIGINALDATE);
        applyTags(album);
        // console.log(JSON.stringify(album));
      }
    } else {
      earliestRecord.errors.day = 'no day';
      if ("month" in album.date) {
        // no day. go by month and add one month for calculations
        delete earliestRecord.errors.month;
        delete earliestRecord.errors.year;
        testEpoch = Date.parse(`${album.year}-${(album.month + 1 < 12 ? album.month + 1: "12-31")}`);
        if (testEpoch < earliestRecord.epoch) {
          earliestRecord.epoch = testEpoch;
          earliestRecord.ORIGINALYEAR = earliestRecord.ORIGINALDATE = earliestRecord.year = earliestRecord.date = album.date.year
          ///Date.parse(earliestRecord.ORIGINALDATE);
          applyTags(album);
        }
      } else {
        // go by year, add a year and subtract a millisec for mafs
        delete earliestRecord.errors.year;
        earliestRecord.errors.month = 'no month';
        testEpoch = Date.parse(`${album.year + 1}`) - 1;
        if (testEpoch < earliestRecord.epoch) {
          earliestRecord.epoch = testEpoch;
          earliestRecord.ORIGINALYEAR = earliestRecord.ORIGINALDATE = earliestRecord.year = earliestRecord.date = album.date.year
          ///Date.parse(earliestRecord.ORIGINALDATE);
          applyTags(album);
        }
      }
    }
    // console.log(earliestRecord.epoch)
    // console.log(JSON.stringify(album))
  });
  delete earliestRecord.epoch;
  delete earliestRecord.errors;
  return earliestRecord;
};

const ffmpegCli = (tags) => {
  ext = filename.match(/.*\.(.*)$/)[1];
  string = "";
  Object.entries(tags).forEach((e) => {
    string += `-metadata ${e[0]}="${e[1]}" `;
  });
  // return `ffmpeg -i "${filename}" -c: copy ${string} "./${tags.ARTIST} - ${tags.ORIGINALYEAR} - ${tags.ALBUM}/${filename.split(".").slice(0, -1).join(".")}.tagged.opus"`;
  return `mkdir -p "./${tags.ARTIST.toString().replace(/[\\|/]/g,
    "_")} - ${tags.ORIGINALYEAR} - ${
  tags.ALBUM.toString().replace(/[\\|/]/g,
    "_")
  }" && ffmpeg -i "${filename}" -map_metadata -1 -c:a copy ${string} "./${tags.ARTIST.toString().replace(/[\\|/]/g,
    "_")} - ${
  tags.ORIGINALYEAR
  } - ${tags.ALBUM.toString().replace(/[\\|/]/g,
    "_")}/${tags.disc}.${("000" + tags.track.toString().replace(/[\\|/]/g, "_")).slice(-2)} - ${
  tags.TITLE.toString().replace(/[\\|/]/g,
    "_")
  }.${ext}" && rm "${filename}"`;
};

console.log(ffmpegCli(getEarliestRelease(results)));
// console.log(getEarliestRelease(results));

//const earliest = getEarliestRelease(results);
//console.log(JSON.stringify(albums));
//console.log(JSON.stringify(earliest))



// .toString().replace(/[\\|/]/g,"_")